1. 컴파일

1) 컴파일이란?
인간이 보기 편하게 만든 코드(자바코드)를 컴퓨터가 이해할 수 있는 언어로 변환하는 것이다.

2) 컴파일 과정
소스파일(.java)을 컴파일러(javac.exe)로 컴파일하면 바이트 코드 파일(.class)파일이 생성된다.
이 바이트 코드 파일은 JVM 구동 명령어(java.exe)에 의해 JVM에서 해석되고 해당 운영체제에 맞는 기계어로 번역된다.

3) IDE (Integrated Development Environment)
IDE란 소스 코드 편집, 컴파일, 디버깅을 한꺼번에 할 수 있는 통합 개발 환경이다.
매번 메모장에 소스 코드를 작성하여 위와 같은 일련의 과정들을 일일이 실행하는 건 번거롭기 때문에 프로그램을 편리하게 개발할 수 있도록 도와주는 도구이다. 
대표적으로 이클립스가 있다. 

4) 환경변수에 경로 설정 
환경변수를 설정하지 않아도 자바를 사용할 수 있다. 다만, 환경변수를 등록하지 않을 경우 임의의 위치에서 자바 명령을 호출하길 원한다면 그 때마다 풀 경로를 입력해야만 한다. 
예를 들어, java파일을 컴파일하길 원할 때 컴파일러를 호출해야 하는데 그 때마다 컴파일러의 풀 경로를 입력해야 한다. 
하지만, 자바 설치 경로를 환경변수로 등록할 경우 어느 위치에서든지 컴파일러를 간편하게 호출할 수 있게 된다.

5) 라이브러리
라이브러리는 코드의 재사용성을 높이기 위해 자주 사용하는 코드(함수)를 모아둔 것이다.

2. 모델1, 모델2(MVC)
- JSP로 구성할 수 있는 웹 어플리케이션의 구조는 크게 모델1, 모델2로 나뉜다.
- 이 두 모델의 큰 차이점은 JSP가 결과의 출력 뿐만 아니라 요청에 대한 모든 로직들을 처리하는가?, JSP는 결과의 출력만 담당하는가? 의 차이이다.

[모델1]
- 모델1은 뷰와 로직을 모두 JSP페이지 하나에서 처리하는 구조를 말한다.
- 모델1의 구성요소 : 1) JSP, 2) 자바빈 혹은 서비스 클래스가 있다.
- JSP페이지 내에 로직 처리를 위한 자바 코드가 출력을 위한 코드와 함께 섞여 삽입된다.
- 브라우저에 요청이 들어오면 JSP페이지는 자신이 직접 자바빈이나 따로 작성한 서비스 클래스를 이용하여 작업을 처리하고, 그 처리한 정보를 클라이언트에 출력한다.
- 간단한 페이지를 구성할 때 주로 쓰인다.

[모델2]
- 모델2는 모든 처리를 JSP페이지 하나가 담당하는 것과는 달리 JSP페이지와 서블릿, 그리고 로직을 위한 클래스가 나뉘어 브라우저 요청을 처리한다.
- 모델2의 구성요소 : 1) 서블릿, 2)JSP, 3)자바빈 혹은 서비스 클래스
- 요청이 들어오면 요청에 대한 로직 처리는 이를 처리할 모델(Model)인 서비스 클래스 혹은 자바빈이 담당하고, 요청 결과는 유저에게 결과를 보여줄 뷰(View)단인 JSP에 출력되며, 이를 위한 모든 흐름 제어는 컨트롤러(Controller)인 서블릿에서 담당한다.

[MVC패턴과 모델2]
- 즉 모델2 구조란 MVC(Model-View-Controller)패턴을 웹 개발에 도입한 구조이며, 모델2와 MVC패턴은 완전히 같은 형태를 갖는다.

Model
서비스 클래스 or 자바빈
비즈니스 로직을 처리하는 모든 것들이 모델에 속한다. 컨트롤러로부터 특정 로직에 대한 처리 요청(ex: 게시판 글쓰기, 회원가입, 로그인 등)이 들어오면 이를 수행하고 수행 결과를 컨트롤러에 반환한다. 필요한 정보는 request객체나 session객체에 저장하기도 한다.
 
View
JSP 페이지
클라이언트에 출력되는 화면을 말한다. 모델1과 달리 로직 처리를 위한 코드가 내포되어 있지 않다. 요청 결과의 출력 뿐만 아니라 컨트롤러 요청을 보내는 용도로도 사용된다.
request객체나 session객체에 저장된 정보를 토대로 화면에 출력한다.

Controller
서블릿
 MVC 패턴(모델2)의 모든 흐름 제어를 맡는다. 브라우저로부터 요청이 들어오면, 어떤 요청인지 분석하여 이 요청을 처리하기 위한 모델을 사용하여 처리한다.
사용한 모델로부터 처리 결과를 받으면 추가로 처리하거나 가공해야할 정보가 있다면 처리 후 request객체나 session객체에 저장하고, 뷰(JSP페이지)를 선택하여 forward나 redirect하여 클라이언트에 출력한다.



3. 클래스와 인스턴스, 패키지
- 클래스란 ‘객체를 정의해놓은 것’ 혹은 ‘객체의 설계도 또는 틀’
- 클래스는 객체를 생성하는 데 사용되며, 객체는 클래스에 정의된 대로 생성된다. 
- 여기서 객체는 실제로 존재하는 것으로서 우리가 주변에서 볼 수 있는 책상, 의자, 자동차와 같은 사물들이 곧 객체
이다. 뿐만 아니라 개념이나 논리와 같은 무형적인 것들도 객체로 여긴다.
- 인스턴스는 객체와 같은 의미이며, 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
- 패키지는 클래스를 모아둔 폴더로, 패키지 안에는 인터페이스 또한 포함시킬 수 있다.
- 서로 관련된 클래스끼리 그룹단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.
- 패키지의 특징 :　1) 하나의 소스파일에는 첫 번째 문장으로 단 한 번의 패키지 선언만을 허용한다.
		 2) 모든 클래스는 반드시 하나의 패키지에 속해야 한다.
		 3) 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다. 

4. 접근지정자, 정보은닉, 캡슐화
- 접근지정자 : 외부에서 클래스의 멤버에 접근할 수 있는 범위를 나타낸다.
	1) private : 동일한 클래스 내에서만 멤버에 접근이 가능하다.
	2) package(default) : 같은 패키지 내에서도 접근이 가능하다.
	3) protected : 다른 패키지라도 상속을 받았다면 접근이 가능하다. 
	4) public : 다른 패키지에서도 접근이 가능하다. 
- 접근지정자를 활용하여 정보은닉과 캡슐화를 구현할 수 있다.
- 캡슐화는 객체의 속성과 관련된 메소드를 하나로 묶는 것, 정보은닉은 데이터와 함수들 중 일부를 외부에 노출시키지 않는 것이다. 
ex)
	myCar.speed = -100; (x) 자동차의 속도는 음수가 될 수 없는데, 외부에서 음수로 변경하면 객체의 무결성이 깨짐
	void setSpeed(double speed) {
		if(speed < 0) {
			this.speed = 0;
			return;
		} else {
			this.speed = speed;
		}
	}
- 이 같은 방식으로 데이터는 외부에서 접근할 수 없도록 막고 메소드는 공개해서 외부에서 메소드를 통해 데이터에 접근하도록 유도할 경우 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장하기 때문에 객체의 무결성을 보존할 수 있다.

5. 오버로딩, 오버라이딩
- 오버로딩은 메소드의 중복정의, 보통 메소드의 이름을 중복하여 정의할 수 없으나 이름이 같은 메소드라고 하더라도 메소드의 매개변수의 특성에 따라 여러 개 정의하는 것을 말한다.
- 오버라이딩은 메소드의 재정의, 상속관계에서 부모 클래스에 추상메소드가 존재한다면, 그것을 자식 클래스에서 재정의 하는 것을 오버라이딩이라 함

6. Exception
- 예외는 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류를 말한다. 이 같은 프로그램 실행 시 발생하는 예외에 대비하여 코드를 작성하는 것을 예외처리라고 하며, 이는 프로그램의 비정상적인 종료를 막고, 정상적인 실행상태를 유지하게 만들어준다.
- 예외 처리를 하기 위해서는 try-catch문을 주로 사용하며, 구조는 다음과 같다.
	try {
		예외가 발생할 가능성이 있는 코드를 넣는다.
	} catch (Exception1 e1) {
		Exception1이 발생했을 경우, 이를 처리하기 위한 코드를 넣는다.
	} catch (Exception2 e2) {
		Exception2가 발생했을 경우, 이를 처리하기 위한 코드를 넣는다.
	}
- throws 키워드를 사용하여 메소드를 호출한 곳으로 예외를 떠넘길 수도 있다. 단, throws 키워드가 붙어있는 메소드는 반드시 try 블록 안에서 호출되어야 한다. 



