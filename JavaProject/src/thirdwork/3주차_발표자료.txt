0. 생성자
[개념]
- 생성자는 인스턴스가 생성될 때 자동으로 호출되는 메소드이다.
- 생성자는 주로 인스턴스의 멤버를 초기화하는 목적으로 사용된다.
- 생성자는 메소드 오버로딩이 가능하기 때문에, 클래스 내 여러 생성자를 정의할 수 있다. 이는 목적에 따라 생성자를 달리 호출하여 적합한 인스턴스를 만들어낼 수 있고, 또한 불필요한 메모리 낭비를 방지할 수 있다. 
[특징]
- 생성자 명은 클래스 명과 동일하다.
- void를 포함한 리턴값을 가지지 않는다.
- 클래스 객체가 생성될 때 반드시 하나의 생성자가 호출된다. 
- 멤버 필드 값을 초기화한다.
- 만약 클래스 내부에 생성자가 하나도 없다면 자동적으로 매개변수와 구현 내용이 없는 default 생성자가 있는 것으로 본다.
- 생성자의 첫번째 줄에 this 키워드를 사용하여 다른 생성자를 호출할 수도 있다.


1. Interface
[정의]
- 인터페이스는 객체의 사용 방법을 정의한 타입이다.
- 인터페이스는 객체의 교환성을 높여주기 때문에 다형성을 구현하는 매우 중요한 역할을 한다.
- 인터페이스는 개발 코드와 객체가 서로 통신하는 접점 역할을 한다.
- 개발코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출시킨다. 이 때문에 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 된다. 
[사용 이유]
- 개발 시간 단축 : 작성된 인터페이스를 구현하는 클래스가 여러 개라고 하더라도, 각각의 클래스가 완성될 때까지 기다리지 않아도 동시에 개발을 진행할 수 있다.
- 표준화 가능 : 프로젝트에 사용되는 기본 틀을 인터페이스로 작성한 다음, 개발자들에게 인터페이스를 구현하여 프로그램을 작성하도록 함으로써 보다 일관되고 정형화된 프로그램의 개발이 가능하다.
- 서로 관계없는 클래스들에게 관계를 맺어 줄 수 있다. : 아무 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 함으로써 관계를 맺어줄 수 있다.
- 독립적인 프로그래밍이 가능 : 인터페이스를 이용하면 클래스의 선언과 구현을 분리시킬 수 있기 때문에 실제구현에 독립적인 프로그램을 작성하는 것이 가능하다. 클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용하여 간접적인 관계로 변경하면, 한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적인 프로그래밍이 가능하다.


2. 다형성
[정의]
- 다형성이란?
다형성은 상속과 깊은 관계가 있다.
객체지향개념에서 다형성이란 '여러 가지 형태를 가질 수 있는 능력'을 의미하며 자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램 적으로 구현하였다.
하나의 객체를 여러 개의 타입으로, 하나의 타입으로 여러 종류의 객체를 여러 가지 모습으로 해석될 수 있는 성격이라고 생각하면 된다.

다형성은 하나의 객체를 여러 가지 타입으로 선언할 수 있다는 뜻이다.
다형성은 개발자들에게는 간단히 말해서 하나의 사물(객체)을 다양한 타입으로 선언하고 사용할 수 있다는 의미로 해석해주면 된다. 일반적으로 어떤 객체가 하나의 분류에만 포함되는 것은 아니다. 대한민국의 국민인 동시에, 남자인 동시에, 서울에 사는 사람 등과 같이 이처럼 다형성은 어떤 사물을 여러 가지 시선으로 바라보는 모습을 생각하면 쉽게 이해할 수 있다.

인터페이스가 상속보다 다형성에 더욱 유연함을 제공한다.

인터페이스는 클래스의 선언 뒤에서 여러 개의 인터페이스를 구현할 수 있게 할 수 있다. 이런 이유 때문에 하나의 객체를 여러 개의 타입으로 바라보는 다형성에는 상속보다 인터페이스가 더 큰 유연함을 제공한다고 할 수 있다.

cf) 인터페이스가 여러 개 올 수 있다는 의미는 다시 말해 ‘여러 타입으로 변수를 선언할 수 있다’라는 것이다. 

인터페이스는 그 목적상 기능을 의미하게 할 수 있다. 즉 ‘어떤 객체가 어떤 기능을 할 수 있는가‘로 설계할 경우에 기능에 초점을 두고 인터페이스로 설계할 수 있다는 얘기이다. 따라서 이렇게 되면 어떤 객체는 여러 가지 기능을 가지게 된다.

결론적으로 인터페이스를 이용하면 하나의 객체가 여러 개의 기능을 가지는 형태로 보이게 만들어줄 수 있다.

마치 상속에서 부모 타입으로 변수를 선언하고 자식 타입으로 객체를 생성하는 코드와 유사하긴 하지만 인터페이스는 더 다양한 형태로 객체를 정의해줄 수 있다. 이것은 마치 부모 클래스의 기능을 물려받는 모습처럼 선언되기는 하지만 상속보다는 더 많은 종류를 보여줄 수 있게 된다. 이런 모습 때문에 일반적으로 다중 상속의 기능을 활용하기 위해서 인터페이스를 사용한다는 설명되는 경우가 많다.

class Tv {

	boolean power;
	int channel;

	void power() { 
		power = power;
	}

	void channelUp() {
		++channel;
	}

	void channelDown() {

		--channel;
	}
}

class CationTv extends Tv {
	String text;//캡션을 보여 주기 위한 문자열

	void captionTv() {
	}
}

지금까지 생성된 인스턴스를 다루기 위해서, 인스턴스의 타입과 일치하는 타입의 참조변수만을 사용했다. 즉, Tv인스턴스를 다루기 위해서는 Tv타입의 참조변수를 사용하고, CaptionTv인스턴스를 다루기 위해서는 CaptionTv타입의 참조변수를 사용했다.

Tv t = new Tv();
CationTv e = new CaptionTv();

이처럼 인스턴스의 타입과 참조변수의 타입이 일치하는 것이 보통이지만, Tv와 CaptionTv클래스가 서로 상속관계에 있을 경우, 다음과 같이 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조하도록 하는 것도 가능하다.

Tv t =new  CationTv();

※ 인스턴스를 같은 타입의 참조변수로 참조하는 것과 조상타입의 참조변수로 참조하는 것의 차이점

CationTv c = new CaptionTv();
Tv t =new CaptionTv();

위의 코드에서 CaptionTv 인스턴스 2개를 생성하고, 참조변수 c, t가 생성된 인스턴스를 하나씩 참조하도록 하였다. 이 경우 실제 인스턴스가 CationTv타입이라 할지라도, 참조변수 t로는 CaptionTv인스턴스의 모든 멤버를 사용할 수 없다. Tv 타입의 참조변수로는 CaptionTv 인스턴스 중에서 Tv클래스의 멤버들(상속받은 멤버포함)만 사용할 수 있다. 따라서, 생성된 CaptionTv 인스턴스의 멤버 중에서 Tv클래스에 정의 되지 않은 멤버, text와 caption()은 참조변수 t로 사용이 불가능하다. 즉, t.text 또는 t.caption()와 같이 할 수 없다는 것이다.

둘 다 같은 타입의 인스턴스지만, 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다.

cf) Caption c = new Tv(); // 컴파일 에러

실제 인스턴스인 Tv의 멤버 개수보다 참조변수 c가 사용할 수 있는 멤버 개수가 더 많기 때문이다.
--> 자손타입의 참조변수로 조상타입의 인스턴스를 참조하는 것은 존재하지 않는 멤버를 사용하고자 할 가능성이 있으므로 허용하지 않는다. 참조변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버 개수보다 같거나 적어야 하는 것이다.


3. mutable immutable 객체
- mutable 객체 : 가변객체로, 생성 후 상태를 바꿀 수 있는 객체 (대표적으로 컬렉션 객체)
- immutable 객체 : 불변객체로, 생성 후 상태를 바꿀 수 없는 객체 (대표적으로 String, 래퍼 클래스의 객체)

- 객체는 참조(reference) 형태로 전달하고 전달 받는다. 객체가 참조를 통해 공유되어 있다면 그 상태가 언제든지 변경될 수 있기 때문에 문제가 될 가능성도 커지게 된다. 이는 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문인데 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다.

- 의도하지 않은 객체의 변경이 발생하는 원인의 대다수는 “레퍼런스를 참조한 다른 객체에서 객체를 변경”하기 때문이다. 이 문제의 해결 방법은 비용은 조금 들지만 객체를 불변객체로 만들어 프로퍼티의 변경을 방지하며 객체의 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 새로운 객체를 생성한 후 변경한다. 또는 Observer 패턴으로 객체의 변경에 대처할 수도 있다.

- 불변 객체를 사용하면 복제나 비교를 위한 조작을 단순화 할 수 있고 성능 개선에도 도움이 된다. 하지만 객체가 변경 가능한 데이터를 많이 가지고 있는 경우 오히려 부적절한 경우가 있다.

불변객체의 특징
	- 장점 : 생성자, 접근메소드에 대한 방어 복사가 필요없다. 
		멀티스레드 환경에서 동기화 처리없이 객체를 공유할 수 있다. 
		불변이기 때문에 객체가 안전한다.
	- 단점 : 객체가 가지는 값마다 새로운 객체가 필요하다. 
		따라서, 새로운 객체를 계속 생성해야 하기 때문에 메모리 누수와 같은 성능저하를 발생시킬 수 있다.


4. I/O
- 프로그램에서 데이터를 외부에서 읽고 다시 외부로 출력하는 작업이 빈번히 일어난다.
- 데이터는 다양한 방식(키보드, 파일, 네트워크)으로 입력될 수 있고, 또한 다양한 방식(모니터, 파일, 네트워크)으로 출력될 수 있다.
- 자바에서 데이터는 스트림을 통해 입출력되므로 스트림의 특징을 잘 이해해야 한다.
- 프로그램이 데이터를 입력받을 때에는 입력스트림, 반대로 데이터를 보낼 때는 출력스트림이라고 부른다.
- 스트림 클래스는 크게 두 종류로 구분된다. 하나는 바이트기반, 하나는 문자기반 스트림이다.

바이트 단위 입출력을 위한 최상위 입출력 스트림 클래스
inputstream / outputstream

바이트 단위 입출력을 위한 하위 스트림 클래스
fileinputstream / fileoutputstream
datainputstream / dataoutputstream
...

문자 단위 입출력을 위한 최상위 입출력 스트림 클래스
Reader / Writer

문자 단위 입출력을 위한 하위 스트림 클래스

filereader / filewriter
inputstreamreader / outputstreamreader
printwriter
...

- 바이트 스트림의 데이터 송수신 특성
: 바이트 스트림은 데이터를 있는 그대로 송수신하는 스트림이다. 문자를 파일에 저장하는 것도 가능하지만 자바 프로그램이 아닌 다른 프로그램을 이용해서 읽게 될 경우 문제가 발생한다. 운영체제별로 고유의 문자표현방식이 존재하는데 해당 운영체제에서 동작하는 프로그램은 해당 운영체제의 문자 표현 방식을 따른다. 따라서 파일에 저장된 데이터는 해당 운영체제의 문자 표현 방식으로 저장되어 있어야 한다.
- 문자 스트림은 해당 운영체제 기반 인코딩 방식을 지원
: 문자 스트림은 해당 운영체제의 문자 인코딩 기준을 따라서 데이터 입출력을 수행한다. 한편, 동영상이나 이미지 파일과 같은 바이너리 파일은 바이트 스트림을 통해 입출력할 수 있다. 


5. Java Memory 와 Java version에 따른 String pool 운영 차이점
public class StringMemoryIntern {

    public static void main(String... args) {
        String literal = "loper";
        String object = new String("loper");
        String intern = object.intern();

        System.out.println(literal == object); // false
        System.out.println(literal.equals(object)); // true
        System.out.println(literal == intern); // true
        System.out.println(literal.equals(intern)); // true
    }

}

- 분명 동일한 “loper”라는 문자열을 선언한 String 객체이다. == 연산의 결과는 false이고 equals 수행 결과는 true이다. equals는 문자열을 비교하기 때문에 같은 문자열에 대해서 true가 맞다. 하지만 == 연산자의 경우 객체의 주소값을 비교하기 때문에 일반 객체처럼 Heap 영역에 생성된 String 객체와 리터럴을 이용해 string constant pool에 저장된 String 객체의 주소값은 다를 수밖에 없다.

- 왜 이런 결과가 나오는 것일까?

- 동작 방식에 대한 이해가 필요하다. String을 리터럴로 선언할 경우 내부적으로 String의 intern() 메서드가 호출되게 된다. intern() 메서드는 주어진 문자열이 string constant pool에 존재하는지 검색하고 있다면 그 주소값을 반환하고 없다면 string constant pool에 넣고 새로운 주소값을 반환하게 된다.

- java 6 이하에서는 PermGen 영역에 String Pool을 저장해 놓았었는데 PermGen영역은 프로그램이 실행되고 있는 동안 확장될 수 없는 고정된 용량을 가지고 있기 때문에 intern되는 String 값이 너무 많아지면 OutOfMemoryException 확률이 높았다. 이 때문에 java7부터 heap에 저장 하도록 변경되었다고 한다.